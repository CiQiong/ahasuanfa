/* 
//全排列 
#include <cstdio>
int a[10],book[10],n;//c语言的全局变量在没有赋值以前默认为0
//因此这里的book数组无需全部再次赋初始值0 
void dfs(int step){//step表示现在站在第几个盒子面前
	int i;
	if(step==n+1){//如果站在第n+1个盒子面前，则表示前n个盒子已经放好扑克牌
		//输出一种序列(1~n号盒子中的扑克牌编号)
		for(i=1;i<=n;i++)
			printf("%d",a[i]);
		printf("\n");
		return;//返回之前的一步(最近一次调用dfs的地方) 
	} 
	//此时站在第step个盒子面前，应该放哪张牌呢？
	//按照1、2、3...n的顺序一一尝试 
	for(i=1;i<=n;i++){
		//判断扑克牌i是否还在手上
		if(book[i]==0){//book[i]等于0表示i号扑克牌仍在手上
			a[step]=i;//将i号扑克放入到第step个盒子中
			book[i]=1;//将book[i]设为1，表示i号扑克已经不在手上 
			//第steo个盒子已经放好扑克牌，接下来需要走到下一个盒子面前 
			dfs(step+1);//递归调用 
			book[i]=0;//一定要将刚才尝试的扑克收回，才能进行下一次尝试 
		}
	}
	return; 
}
int main(){
	scanf("%d",&n);//输入的时候要注意n为1~9之间的整数
	dfs(1);//首先站在1号小盒子面前
	return 0; 
}
*/

//坑爹的奥数 
#include <cstdio>
int a[10],book[10],total=0;
void dfs(int step){//step表示现在站在第几个盒子面前
	int i;
	if(step==10){//如果站在第10个盒子面前，
		           //则表示前面9个盒子已经放好扑克牌
		//判断是否满足等式？？？+？？？=？？？
		if(a[1]*100+a[2]*10+a[3]+a[4]*100+a[5]*10+a[6]==
			 a[7]*100+a[8]*10+a[9]){
			//如果满足要求，可行解+1，并打印这个解
			total++;
			printf("%d%d%d+%d%d%d=%d%d%d\n",a[1],a[2],a[3],a[4],
							a[5],a[6],a[7],a[8],a[9]);
		}
		return;//返回之前的一步(最近调用的地方) 
	}
	//此时站在第step个盒子面前，应该放哪张牌呢？
	//按照1、2、4...n的顺序一一尝试
	for(i=1;i<=9;i++){
		//判断扑克牌是否还在手上
		if(book[i]==0){//book[i]为0表示扑克牌还在手上
			//开始尝试使用扑克牌i
			a[step]=i;//将i号扑克放入到第step个盒子中
			book[i]=1;//将book[i]设为1，表示i号扑克已经不在手上 
			//第steo个盒子已经放好扑克牌，接下来需要走到下一个盒子面前 
			dfs(step+1);//递归调用 
			book[i]=0;//一定要将刚才尝试的扑克收回，才能进行下一次尝试 
		} 
	}
	return;
}
int main(){
	dfs(1);//首先站在1号小盒子面前
	printf("tatal=%d",total/2);
	return 0;
}
